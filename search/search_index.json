{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"","text":"<p><code>PineAPFEL</code> is a C++ library and CLI tool for creating and evolving PineAPPL interpolation grids using APFEL++. It can fill grids with analytically computed coefficient functions for unpolarized and longitudinally polarized DIS, SIA, and SIDIS structure functions, and evolve them into FK tables via DGLAP evolution.</p> <p>All physics parameters (coupling constants, thresholds, perturbative order, etc.) are specified through YAML configuration files through a theory card, an operator card, and optionally a grid card rather than being hardcoded.</p>"},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>Building &amp; Installing</li> <li>Writing configuration cards</li> <li>Producing PineAPPL grids</li> <li>PineAPFEL CLI</li> <li>Using PineAPFEL as a Library</li> </ul>"},{"location":"building/","title":"Building & Installing","text":"<p>The following provides detailed instructions for building and installing <code>PineAPFEL</code> and its APIs and tools. <code>PineAPFEL</code> depends on the following libraries: PineAPPL for producing and reading fast interpolation grids, APFEL++ for the DGLAP evolution kernels and YAML-CPP for parsing the theory and operator YAML cards.</p>"},{"location":"building/#c-library-and-cli","title":"C++ library and CLI","text":"CMake Meson <pre><code>cd pineapfel\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j\"$(nproc)\"\n</code></pre> <p>To install system-wide:</p> <pre><code>make install\n</code></pre> <pre><code>cd pineapfel\nmeson setup builddir\nninja -C builddir\n</code></pre> <p>To install system-wide:</p> <pre><code>meson install -C builddir\n</code></pre> <p>Note</p> <p>If <code>APFEL++</code> is installed in a non-standard location, you may need to set <code>LD_LIBRARY_PATH</code> at runtime:</p> <pre><code>export LD_LIBRARY_PATH=/path/to/lib:$LD_LIBRARY_PATH\n</code></pre>"},{"location":"building/#python-api","title":"Python API","text":"<p>The Python bindings require pybind11 and PineAPPL in addition to the C++ dependencies above. They are built automatically by Meson when Python 3 and <code>pybind11</code> are found.</p>"},{"location":"building/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install pybind11 pineappl numpy\n</code></pre>"},{"location":"building/#building","title":"Building","text":"Meson <p>The Python extension module is compiled alongside the C++ library.  No extra configuration flags are needed \u2014 Meson detects Python and pybind11 automatically:</p> <pre><code>meson setup builddir\nninja -C builddir\n</code></pre> <p>A file named <code>_pineapfel.cpython-&lt;version&gt;-&lt;arch&gt;.so</code> appears in <code>builddir/</code>.</p>"},{"location":"building/#installing","title":"Installing","text":"System-wide In-tree Development <pre><code># `pineapfel` is placed in your Python's site-packages alongside the C++ library.\nmeson install -C builddir\n</code></pre> <p>Symlink the built extension into the source package so <code>import pineapfel</code> works without installation:</p> <pre><code>ln -sf \"$(pwd)/builddir/_pineapfel.cpython-$(python3 -c 'import sys; v=sys.version_info; print(f\"{v.major}{v.minor}\")')-\"*.so pineapfel_pyapi/pineapfel/\n\n# Prepend the source tree to PYTHONPATH:\nexport PYTHONPATH=\"$(pwd)/pineapfel_pyapi:$PYTHONPATH\"\npython3 -c \"import pineapfel; print('OK')\"\n</code></pre> <p>Note</p> <p>See Python API for a full usage guide and API reference.</p>"},{"location":"cli/","title":"CLI Interface","text":""},{"location":"cli/#using-the-cli","title":"Using the CLI","text":"<p>PineAPFEL provides two command-line executables:</p> <ul> <li><code>pineapfel-build</code> \u2014 creates a PineAPPL grid filled with APFEL++ coefficient functions</li> <li><code>pineapfel-evolve</code> \u2014 evolves a PineAPPL grid into an FK table</li> </ul>"},{"location":"cli/#pineapfel-build","title":"<code>pineapfel-build</code>","text":"<p>Creates a PineAPPL grid from a grid card, theory card, and operator card. The grid is filled with analytically computed coefficient functions for the specified process and observable (see Grid creation for details on supported processes).</p> <pre><code>pineapfel-build &lt;grid.yaml&gt; &lt;theory.yaml&gt; &lt;operator.yaml&gt; [-o output.pineappl.lz4]\n</code></pre> <p>If <code>-o</code> is not specified, the output filename is derived from the grid card by replacing <code>.yaml</code> with <code>.pineappl.lz4</code>.</p>"},{"location":"cli/#examples","title":"Examples","text":"<pre><code># Build a DIS F2 grid (output: runcards/grid_dis.pineappl.lz4)\npineapfel-build runcards/grid_dis.yaml runcards/theory.yaml runcards/operator.yaml\n\n# Build an SIA grid with a custom output name\npineapfel-build runcards/grid_sia.yaml runcards/theory.yaml runcards/operator.yaml \\\n    -o sia_f2.pineappl.lz4\n\n# Build a SIDIS F2 grid (two-convolution: PDF \u2297 FF)\npineapfel-build runcards/grid_sidis.yaml runcards/theory.yaml runcards/operator.yaml \\\n    -o sidis_f2.pineappl.lz4\n\n# Build a DIS F2 grid in the FFN massive scheme\n# (requires MassScheme: FFN in the grid card and HeavyQuarkMasses in the theory card)\npineapfel-build runcards/grid_dis_ffn.yaml runcards/theory.yaml runcards/operator.yaml \\\n    -o dis_f2_ffn.pineappl.lz4\n\n# Build a DIS F2 FONLL grid (F_ZM + F_FFN)\npineapfel-build runcards/grid_dis_fonll.yaml runcards/theory.yaml runcards/operator.yaml \\\n    -o dis_f2_fonll.pineappl.lz4\n</code></pre>"},{"location":"cli/#pineapfel-evolve","title":"<code>pineapfel-evolve</code>","text":"<p>Evolves an existing PineAPPL interpolation grid into an FK table using APFEL++ DGLAP evolution operators. The input grid can be one produced by <code>pineapfel-build</code> or any other valid PineAPPL grid.</p> <pre><code>pineapfel-evolve &lt;grid.pineappl.lz4&gt; &lt;theory.yaml&gt; &lt;operator.yaml&gt; [-o output.pineappl.lz4]\n</code></pre> <p>If <code>-o</code> is not specified, the output is written to <code>&lt;input&gt;.fk.pineappl.lz4</code>.</p>"},{"location":"cli/#examples_1","title":"Examples","text":"<pre><code># Default output name\npineapfel-evolve grid.pineappl.lz4 theory.yaml operator.yaml\n\n# Custom output name\npineapfel-evolve grid.pineappl.lz4 theory.yaml operator.yaml -o my_fktable.pineappl.lz4\n</code></pre>"},{"location":"cli/#full-pipeline","title":"Full pipeline","text":"<p>A typical workflow chains grid creation and evolution. The same commands work for DIS, SIA, and SIDIS \u2014 only the grid card differs:</p> <pre><code># DIS F2: create and evolve\npineapfel-build runcards/grid_dis.yaml runcards/theory.yaml runcards/operator.yaml \\\n    -o dis_f2.pineappl.lz4\npineapfel-evolve dis_f2.pineappl.lz4 runcards/theory.yaml runcards/operator.yaml \\\n    -o dis_f2.fk.pineappl.lz4\n\n# SIDIS F2: create and evolve (two-convolution grid)\npineapfel-build runcards/grid_sidis.yaml runcards/theory.yaml runcards/operator.yaml \\\n    -o sidis_f2.pineappl.lz4\npineapfel-evolve sidis_f2.pineappl.lz4 runcards/theory.yaml runcards/operator.yaml \\\n    -o sidis_f2.fk.pineappl.lz4\n</code></pre> <p>The resulting FK table can be convoluted with PDFs (and FFs for SIDIS) using the <code>pineappl</code> CLI or any PineAPPL-compatible tool.</p>"},{"location":"configuration-cards/","title":"Configuration cards","text":""},{"location":"configuration-cards/#writing-configuration-cards","title":"Writing configuration cards","text":"<p>PineAPFEL uses YAML configuration files to specify all physics and numerical parameters. The theory card and operator card are required for both grid creation and evolution. An additional grid card is needed when creating grids with <code>build_grid()</code> or <code>pineapfel-build</code> (see Grid creation for the full grid card reference).</p>"},{"location":"configuration-cards/#theory-card","title":"Theory card","text":"<pre><code># Initial evolution scale in GeV.\nmu0: 1.0\n\n# QCD perturbative order:\n#   0 = LO\n#   1 = NLO\n#   2 = NNLO\nPerturbativeOrder: 2\n\n# Reference scale for alpha_s in GeV.\nQRef: 91.1876\n\n# Value of alpha_s(Q_ref)\nAlphaQCDRef: 0.118\n\n# Quark mass thresholds in GeV, one per active flavor.\n# Ordering: up, down, strange, charm, bottom.\n# Use 0.0 for massless quarks. The length determines the maximum number\n# of active flavors (nf_max).\nQuarkThresholds: [0.0, 0.0, 0.0, 1.4, 4.75]\n\n# Physical heavy-quark masses for massive coefficient functions, all 6\n# flavors required (up, down, strange, charm, bottom, top) in GeV.\n# Used when MassScheme: FFN or MassScheme: FONLL is set in the grid card.\n# Defaults to QuarkThresholds padded to 6 entries (top = 172.0 GeV) if absent.\nHeavyQuarkMasses: [0.0, 0.0, 0.0, 1.4, 4.75, 172.0]\n\n# CKM squared matrix elements |Vij|^2, 9 entries in row-major order:\n# [Vud^2, Vus^2, Vub^2, Vcd^2, Vcs^2, Vcb^2, Vtd^2, Vts^2, Vtb^2]\n# Only used for CC grids. Optional: defaults to standard PDG values if absent.\nCKM: [0.94922, 0.05077, 0.00001, 0.05073, 0.94760, 0.00168, 0.00007, 0.00162, 0.99831]\n\n# Output flavor PIDs written to the FK table.\n# These define the pids_out dimension of the evolution operator.\n# Standard PDG codes: 1=d, 2=u, 3=s, 4=c, 5=b, -1=dbar, ..., 21=gluon, 22=photon\nFlavors: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 21]\n\n# --- Massive coefficient function tabulation parameters ---\n# These control the xi = Q^2/m^2 interpolation grid built by APFEL++ when\n# MassScheme: FFN or MassScheme: FONLL is set in the grid card.\n# All fields are optional; the values shown are the defaults.\n\n# Number of xi interpolation points.\nMassNxi: 150\n\n# xi range [MassXiMin, MassXiMax] over which massive CFs are tabulated.\nMassXiMin: 0.05\nMassXiMax: 10000.0\n\n# Polynomial interpolation degree in xi.\nMassIntDeg: 3\n\n# Lambda parameter for the xi-grid density (controls spacing near xi = 0).\nMassLambda: 0.0005\n\n# Interpolation mode passed to TabulateObject (0 = default).\nMassIMod: 0\n\n# Set to true to use combined QCD+QED evolution.\n# When false (default), pure QCD evolution is used.\nQED: false\n\n# --- QED-specific fields (ignored when QED: false) ---\n\n# Value of alpha_em at the reference scale\nAlphaQEDRef: 0.00729927\n\n# Lepton mass thresholds in GeV.\n# Leave empty to forbid lepton creation during evolution.\nLeptonThresholds: []\n</code></pre>"},{"location":"configuration-cards/#operator-card","title":"Operator card","text":"<pre><code># x-space interpolation grid.\n# Each sub-grid is defined by:\n#   n_knots:     number of interpolation knots\n#   x_min:       lower edge of the sub-grid in Bjorken x\n#   poly_degree: polynomial interpolation degree\n#\n# The sub-grids are joined into a single APFEL++ Grid object.\nxgrid:\n  - n_knots: 80\n    x_min: 1.0e-5\n    poly_degree: 3\n  - n_knots: 40\n    x_min: 1.0e-1\n    poly_degree: 3\n\n# Tabulation parameters for the running coupling(s).\n# These are passed to the apfel::TabulateObject constructor:\n#   n_points:     number of interpolation points\n#   q_min:        minimum scale in GeV for the tabulation\n#   n_steps:      number of steps in the tabulation grid\n#   interp_degree: interpolation degree for the tabulated object\ntabulation:\n  n_points: 200\n  q_min: 0.9\n  n_steps: 13001\n  interp_degree: 3\n\n# Scale variation factors: [xi_R, xi_F, xi_A]\n# Use [1.0, 1.0, 1.0] for central predictions.\nxi: [1.0, 1.0, 1.0]\n</code></pre>"},{"location":"evolution-modes/","title":"QCD vs QCD\u2297QED","text":"<p>The evolution mode is controlled by the <code>QED</code> field in the theory card:</p> Mode <code>QED</code> Basis size DGLAP objects Coupling Pure QCD <code>false</code> 13 \u00d7 13 <code>apfel::DglapObjects</code> <code>apfel::AlphaQCD</code> QCD+QED <code>true</code> 20 \u00d7 20 <code>apfel::DglapObjectsQCDQED</code> <code>apfel::AlphaQCDQED</code> <p>In QCD mode, PineAPFEL supports three convolution types (determined automatically from the grid):</p> <ul> <li><code>UNPOL_PDF</code> \u2014 unpolarised PDFs</li> <li><code>POL_PDF</code> \u2014 longitudinally polarised PDFs</li> <li><code>UNPOL_FF</code> \u2014 unpolarised fragmentation functions</li> </ul> <p>In QCD+QED mode, PineAPFEL currently supports:</p> <ul> <li><code>UNPOL_PDF</code> \u2014 unpolarised PDFs with QED corrections</li> </ul>"},{"location":"grid-creation/","title":"Grid creation","text":""},{"location":"grid-creation/#creating-grids","title":"Creating grids","text":"<p>PineAPFEL can create PineAPPL interpolation grids pre-filled with analytically computed coefficient functions from APFEL++. This is useful for structure function computations where the hard-scattering kernels are known analytically and only the non-perturbative input (PDFs or Fragmentation Functions) needs to be provided at convolution time.</p> <p>The grid creation workflow requires three YAML configuration files:</p> <ol> <li>A grid card that defines the process, observable, binning, and perturbative orders</li> <li>A theory card that specifies the QCD parameters (coupling, thresholds, perturbative order)</li> <li>An operator card that defines the x-space interpolation grid and tabulation parameters</li> </ol>"},{"location":"grid-creation/#supported-processes-and-observables","title":"Supported processes and observables","text":"<p>The <code>build_grid()</code> function currently supports the following combinations:</p> Process Observable Current APFEL++ initializer (ZM) Mass schemes DIS \\(F_2\\) NC <code>InitializeF2NCObjectsZM</code> ZM, FFN, FONLL DIS \\(F_L\\) NC <code>InitializeFLNCObjectsZM</code> ZM, FFN, FONLL DIS \\(F_3\\) NC <code>InitializeF3NCObjectsZM</code> ZM only DIS \\(F_2\\) CC\\(+\\) <code>InitializeF2CCPlusObjectsZM</code> ZM only DIS \\(F_L\\) CC\\(+\\) <code>InitializeFLCCPlusObjectsZM</code> ZM only DIS \\(F_3\\) CC\\(+\\) <code>InitializeF3CCPlusObjectsZM</code> ZM only DIS \\(F_2\\) CC\\(-\\) <code>InitializeF2CCMinusObjectsZM</code> ZM only DIS \\(F_L\\) CC\\(-\\) <code>InitializeFLCCMinusObjectsZM</code> ZM only DIS \\(F_3\\) CC\\(-\\) <code>InitializeF3CCMinusObjectsZM</code> ZM only SIA \\(F_2\\) NC <code>InitializeF2NCObjectsZMT</code> ZM only SIA \\(F_L\\) NC <code>InitializeFLNCObjectsZMT</code> ZM only SIA \\(F_3\\) NC <code>InitializeF3NCObjectsZMT</code> ZM only SIDIS \\(F_2\\) NC <code>InitializeSIDIS</code> ZM only SIDIS \\(F_L\\) NC <code>InitializeSIDIS</code> ZM only DIS (polarized) \\(g_1\\) NC <code>Initializeg1NCObjectsZM</code> ZM only DIS (polarized) \\(g_L\\) NC <code>InitializegLNCObjectsZM</code> ZM only DIS (polarized) \\(g_4\\) NC <code>Initializeg4NCObjectsZM</code> ZM only SIDIS (polarized) \\(G_1\\) NC <code>InitializeSIDISpol</code> ZM only <p>Polarized grids are selected by setting <code>Polarized: true</code> in the grid card. The <code>Observable</code> field retains its unpolarized name (<code>F2</code>, <code>FL</code>, <code>F3</code>) and is interpreted as the corresponding polarized observable (\\(g_1\\), \\(g_L\\), \\(g_4\\), or \\(G_1\\) for SIDIS) when <code>Polarized: true</code>.</p> <p>The mass scheme is selected with the <code>MassScheme</code> field in the grid card (see Mass scheme below). Combinations that only support ZM will emit a warning and fall back to ZM when a non-ZM scheme is requested.</p> <p>What is not yet supported</p> <ul> <li>SIA + CC is not supported (APFEL++ only provides CC initializers for DIS).</li> <li>SIDIS + CC is not supported.</li> <li>SIDIS + F3 is not supported (APFEL++ does not provide SIDIS F3 coefficient functions).</li> <li>Polarized + CC is not supported.</li> <li>Polarized SIA is not supported (APFEL++ does not provide time-like polarized SF initializers).</li> <li>Polarized SIDIS + FL is not supported (only \\(G_1\\) is available).</li> <li>QCD+QED coefficient functions are not implemented in grid filling (QED corrections   are only available in the evolution step).</li> </ul>"},{"location":"grid-creation/#convolution-types","title":"Convolution types","text":"<p>Each process type requires a specific convolution type, which determines the type of non-perturbative input the grid will be convoluted with:</p> Process <code>ConvolutionTypes</code> Description DIS <code>[(UN)POL_PDF]</code> (Un)polarised parton distribution functions SIA <code>[(UN)POL_FF]</code> (Un)polarised fragmentation functions SIDIS <code>[(UN)POL_PDF, (UN)POL_FF]</code> PDF for the initial state, FF for the final state"},{"location":"grid-creation/#mass-scheme","title":"Mass scheme","text":"<p>The heavy-quark mass scheme is set via the <code>MassScheme</code> field in the grid card:</p> Value Description <code>ZM</code> Zero-mass Variable Flavor Number <code>(default)</code>. Quarks are massless above their thresholds. Applies to all processes and observables. <code>FFN</code> Fixed-Flavor Number. Uses <code>InitializeF2/FLNCObjectsMassive</code> from APFEL++. Massive charm and bottom coefficient functions depending on \\(\\xi = Q^2/m^2\\) are included. DIS NC \\(F_2\\)/\\(F_L\\) only. <code>FONLL</code> FONLL scheme. Implemented as \\(F_\\mathrm{FONLL} = F_\\mathrm{ZM} + F_\\mathrm{FFN}\\), following APFEL++ conventions. Available for DIS NC \\(F_2\\)/\\(F_L\\) only. <code>MassiveZero</code> Massless limit of FFN (<code>InitializeF2/FLNCObjectsMassiveZero</code>). In APFEL++ the total channel is set to zero for this initializer, so the resulting grid carries zero coefficient functions. Included for completeness. <p>Warning</p> <p>When a non-ZM scheme is requested for an unsupported combination (CC current, \\(F_3\\), polarized, SIA, SIDIS), PineAPFEL prints a warning and falls back to ZM automatically.</p> <p>The heavy-quark masses used by FFN and FONLL are read from the <code>HeavyQuarkMasses</code> field in the theory card (6 entries, all flavors including top). The \u03be-grid tabulation is controlled by the <code>MassNxi</code>, <code>MassXiMin</code>, <code>MassXiMax</code>, <code>MassIntDeg</code>, <code>MassLambda</code>, and <code>MassIMod</code> theory-card fields. See Configuration cards for the full list.</p>"},{"location":"grid-creation/#perturbative-orders","title":"Perturbative orders","text":""},{"location":"grid-creation/#dis-and-sia-unpolarized","title":"DIS and SIA (unpolarized)","text":"<p>The coefficient functions are available at the following perturbative orders:</p> <code>alpha_s</code> power Label \\(F_2\\)/\\(F_L\\) content \\(F_3\\) content 0 LO \\(\\delta(1-x)\\) for quarks, 0 for gluon \\(\\delta(1-x)\\) for quarks, 0 for gluon 1 NLO \\(C_{2,\\mathrm{NS}}^{(1)}\\), \\(C_{2,g}^{(1)}\\) \\(C_{3,\\mathrm{NS}}^{(1)}\\), no gluon 2 NNLO \\(C_{2,\\mathrm{NS}}^{(2)}\\), \\(C_{2,\\mathrm{PS}}^{(2)}\\), \\(C_{2,g}^{(2)}\\) \\(C_{3,\\mathrm{NS}}^{(2)}\\), no gluon"},{"location":"grid-creation/#dis-polarized","title":"DIS (polarized)","text":"<p>For polarized DIS (<code>ConvolutionTypes: [POL_PDF]</code>), the structure functions \\(g_1\\), \\(g_L\\), and \\(g_4\\) are selected instead. The available coefficient functions mirror the unpolarized case:</p> <code>alpha_s</code> power Label \\(g_1\\) / \\(g_L\\) content \\(g_4\\) content 0 LO \\(\\delta(1-x)\\) for quarks, 0 for gluon \\(\\delta(1-x)\\) for quarks, 0 for gluon 1 NLO \\(G_{1,\\mathrm{NS}}^{(1)}\\), \\(G_{1,g}^{(1)}\\) \\(G_{4,\\mathrm{NS}}^{(1)}\\), no gluon 2 NNLO \\(G_{1,\\mathrm{NS}}^{(2)}\\), \\(G_{1,\\mathrm{PS}}^{(2)}\\), \\(G_{1,g}^{(2)}\\) \\(G_{4,\\mathrm{NS}}^{(2)}\\), no gluon"},{"location":"grid-creation/#sidis-unpolarized","title":"SIDIS (unpolarized)","text":"<p>SIDIS coefficient functions depend on two momentum-fraction variables (\\(x\\) and \\(z\\)) and are provided as <code>DoubleObject&lt;Operator&gt;</code> instances by APFEL++. The available terms per channel type at each order are:</p> <code>alpha_s</code> power Label \\(qq\\) \\(gq\\) \\(qg\\) 0 LO \\(C_{2,qq}^{(0)}\\) \u2014 \u2014 1 NLO \\(C_{2,qq}^{(1)}\\) \\(C_{2,gq}^{(1)}\\) \\(C_{2,qg}^{(1)}\\) 2 NNLO \\(C_{2,qq}^{(2)}\\) (\\(n_f\\)-dependent) \u2014 \u2014 <p>The channel labels refer to the convolution pair (PDF flavour, FF flavour): \\(qq\\) = quark PDF \u2297 quark FF, \\(gq\\) = quark PDF \u2297 gluon FF, \\(qg\\) = gluon PDF \u2297 quark FF. The same coefficient functions apply to \\(F_L\\) with \\(C_{L,qq/gq/qg}\\) replacing \\(C_{2,\\ldots}\\); \\(F_L\\) has no LO contribution.</p>"},{"location":"grid-creation/#sidis-polarized","title":"SIDIS (polarized)","text":"<p>For polarized SIDIS (first entry of <code>ConvolutionTypes</code> is <code>POL_PDF</code>), only \\(G_1\\) is available (set <code>Observable: F2</code>). The coefficient function structure mirrors the unpolarized \\(F_2\\) case:</p> <code>alpha_s</code> power Label \\(qq\\) \\(gq\\) \\(qg\\) 0 LO \\(G_{1,qq}^{(0)}\\) \u2014 \u2014 1 NLO \\(G_{1,qq}^{(1)}\\) \\(G_{1,gq}^{(1)}\\) \\(G_{1,qg}^{(1)}\\) 2 NNLO \\(G_{1,qq}^{(2)}\\) (\\(n_f\\)-dependent) \u2014 \u2014 <p>The orders are specified in the grid card via the <code>Orders</code> field. Each order entry is a 5-element array <code>[alpha_s, alpha, log_xir, log_xif, log_xia]</code>. For pure QCD coefficient functions, only the <code>alpha_s</code> power matters; the remaining entries should be set to 0.</p> <p>Each entry stores the coefficient function at that specific power of \\(\\alpha_s\\), not the cumulative sum. For a complete NNLO prediction, all three orders (LO, NLO, NNLO) must be listed so that the grid contains separate subgrids for each perturbative contribution.</p> <p>Warning</p> <p>Orders beyond NNLO (<code>alpha_s &gt; 2</code>) are silently skipped during grid filling, even though APFEL++ provides N3LO coefficient functions for some observables. This is a current limitation that may be lifted in a future release.</p>"},{"location":"grid-creation/#channel-decomposition","title":"Channel decomposition","text":"<p>Channels are automatically derived by <code>build_grid()</code> from the process, observable, and the number of active flavours. You do not need to specify them in the grid card. The number of active flavours \\(n_{f}^{\\mathrm{max}}\\) is determined from the maximum \\(Q^2\\) across all bins using the quark thresholds from the theory card.</p> <p>The <code>derive_channels()</code> function generates channels in the physical (PDG) basis.</p>"},{"location":"grid-creation/#dis-and-sia-channels","title":"DIS and SIA channels","text":"<p>For \\(F_2\\) and \\(F_L\\) (C-even, Neutral Current):</p> <ul> <li>One quark channel per active flavour \\(q = 1, \\ldots, n_{f}^{\\mathrm{max}}\\):   <code>pids: [[q], [-q]]</code>, <code>factors: [1.0, 1.0]</code> (i.e. \\(q + \\bar{q}\\))</li> <li>One gluon channel: <code>pids: [[21]]</code>, <code>factors: [1.0]</code></li> </ul> <p>For \\(F_3\\) (C-odd, Neutral Current):</p> <ul> <li>One quark channel per active flavour \\(q = 1, \\ldots, n_{f}^{\\mathrm{max}}\\):   <code>pids: [[q], [-q]]</code>, <code>factors: [1.0, -1.0]</code> (i.e. \\(q - \\bar{q}\\))</li> <li>No gluon channel (\\(C_\\mathrm{G} = 0\\) at all perturbative orders)</li> </ul> <p>For Charged-Current (CC) processes, the channel structure depends on both the observable and the CC sign variant. The C-parity of the observable determines the quark combination:</p> <ul> <li>C-even (factors \\([1, 1]\\), i.e. \\(q + \\bar{q}\\)):   \\(F_2\\)/\\(F_L\\) CC\\(+\\), \\(F_3\\) CC\\(-\\)</li> <li>C-odd (factors \\([1, -1]\\), i.e. \\(q - \\bar{q}\\)):   \\(F_2\\)/\\(F_L\\) CC\\(-\\), \\(F_3\\) CC\\(+\\)</li> </ul> <p>A gluon channel is present only for \\(F_2/F_L\\) with NC or CC\\(+\\). For CC, the per-quark weights \\(w_q\\) are the sum of CKM\u00b2 elements where quark \\(q\\) participates (filtered by active partner flavours), replacing the electroweak charges used in NC.</p> <p>For example, with 5 active flavours and observable F2 NC, the auto-derived channels are:</p> Channel PIDs Factors \\(d + \\bar{d}\\) <code>[[1], [-1]]</code> <code>[1.0, 1.0]</code> \\(u + \\bar{u}\\) <code>[[2], [-2]]</code> <code>[1.0, 1.0]</code> \\(s + \\bar{s}\\) <code>[[3], [-3]]</code> <code>[1.0, 1.0]</code> \\(c + \\bar{c}\\) <code>[[4], [-4]]</code> <code>[1.0, 1.0]</code> \\(b + \\bar{b}\\) <code>[[5], [-5]]</code> <code>[1.0, 1.0]</code> \\(g\\) <code>[[21]]</code> <code>[1.0]</code> <p>The per-channel coefficient functions are constructed from the APFEL++ operators \\(C_\\mathrm{NS}\\), \\(C_\\mathrm{S}\\), and \\(C_\\mathrm{G}\\) using the general formula:</p> Channel Coefficient function Quark \\(q\\) \\(\\mathcal{C}_q = w_q \\, C_\\mathrm{NS} + \\frac{\\Sigma_w}{6}\\,(C_\\mathrm{S} - C_\\mathrm{NS})\\) Gluon \\(\\mathcal{C}_g = \\Sigma_w \\, C_\\mathrm{G}\\) <p>where \\(w_q\\) is the per-quark weight (electroweak charge \\(e_q^2\\) for NC, or CKM weight for CC), \\(\\Sigma_w = \\sum_{i=1}^{n_f^\\mathrm{light}} w_i\\) sums over light quarks only, and the factor of 6 matches the internal normalisation convention used in APFEL++'s <code>DISNCBasis</code>/<code>DISCCBasis</code>. APFEL++ sets \\(C_\\mathrm{S} = C_\\mathrm{NS}\\) and/or \\(C_\\mathrm{G} = 0\\) where the physics requires it, so the same formula works for all observables and currents.</p> <p>For the FFN and FONLL schemes, all \\(n_f^\\mathrm{max}\\) quark channels contribute to the pure-singlet (PS) term \\(\\frac{\\Sigma_w}{6}(C_\\mathrm{S}-C_\\mathrm{NS})\\): light quarks \\((q \\leq n_f^\\mathrm{light})\\) also receive the non-singlet (NS) weight \\(w_q\\), while heavy quarks \\((q &gt; n_f^\\mathrm{light})\\) have \\(w_q = 0\\) for the NS term. This ensures that the summed PS contribution is proportional to the full SIGMA distribution \\(\\sum_{i=1}^{n_f^\\mathrm{max}} 2f_i\\) as required by APFEL++. Additionally, heavy-quark massive gluon coefficients \\(C_\\mathrm{G}^{(\\mathrm{h})}\\) are accumulated into the gluon channel weighted by \\(e_{q_h}^2\\).</p>"},{"location":"grid-creation/#sidis-channels","title":"SIDIS channels","text":"<p>SIDIS grids carry two convolutions (PDF \u2297 FF), so each channel entry specifies a pair of PIDs rather than a single one. Three channel types are generated per active quark \\(q = 1, \\ldots, n_{f}^{\\mathrm{max}}\\):</p> Channel type PIDs Factors Description \\(qq\\) <code>[[q, q], [-q, -q]]</code> <code>[1.0, 1.0]</code> Quark PDF \u2297 quark FF (and anti-quark) \\(gq\\) <code>[[q, 21], [-q, 21]]</code> <code>[1.0, 1.0]</code> Quark PDF \u2297 gluon FF \\(qg\\) <code>[[21, q], [21, -q]]</code> <code>[1.0, 1.0]</code> Gluon PDF \u2297 quark FF <p>The channel ordering in the grid is <code>qq</code>, <code>gq</code>, <code>qg</code> for quark 1, then <code>qq</code>, <code>gq</code>, <code>qg</code> for quark 2, and so on. With 5 active flavours this gives 15 channels in total.</p> <p>The electroweak weight \\(e_q^2\\) is applied per-quark directly to the subgrid values during filling; the channel PIDs themselves are charge-neutral in the grid card.</p> <p>Note</p> <p>The <code>Channels</code> field in the grid card is still accepted for backward compatibility, but it is always overridden by the auto-derived channels in <code>build_grid()</code>. It is recommended to omit <code>Channels</code> from the grid card entirely.</p>"},{"location":"grid-creation/#the-grid-card","title":"The grid card","text":"<p>The grid card defines the structure of the PineAPPL grid. Below is a complete reference with all fields.</p> <pre><code># The scattering process.\n# Supported values: DIS, SIA, SIDIS\nProcess: DIS\n\n# The structure function observable.\n# Supported values: F2, FL, F3\n# Optional, defaults to F2.\nObservable: F2\n\n# The electroweak current type.\n# Supported values: NC, CC\n# Optional, defaults to NC.\nCurrent: NC\n\n# CC sign variant (only used when Current: CC).\n# Supported values: Plus, Minus\n# Plus  = (F(nu) + F(nubar)) / 2\n# Minus = (F(nu) - F(nubar)) / 2\n# Optional, defaults to Plus.\n# CCSign: Plus\n\n# Heavy-quark mass treatment scheme.\n# Supported values: ZM, FFN, FONLL, MassiveZero\n#   ZM          \u2014 zero-mass VFN scheme (default for all processes)\n#   FFN         \u2014 fixed-flavor-number scheme with massive CFs (DIS NC F2/FL only)\n#   FONLL       \u2014 FONLL = F_ZM + F_FFN (DIS NC F2/FL only)\n#   MassiveZero \u2014 massless limit of FFN; outputs zero CFs (APFEL++ convention)\n# For unsupported combinations the scheme falls back to ZM with a warning.\n# Optional, defaults to ZM.\n# MassScheme: ZM\n\n# PID basis for the channel definitions.\n# Supported values: PDG, EVOL\nPidBasis: PDG\n\n# Hadron PIDs involved in the process (one per convolution).\n#   DIS:   [2212]        (proton)\n#   SIA:   [211]         (pion)\n#   SIDIS: [2212, 211]   (proton + pion)\nHadronPids: [2212]\n\n# Convolution types (one per convolution).\n#   UNPOL_PDF  \u2014 unpolarised parton distributions\n#   POL_PDF    \u2014 longitudinally polarised parton distributions\n#   UNPOL_FF   \u2014 unpolarised fragmentation functions\n#   POL_FF     \u2014 polarised fragmentation functions\n#\n# Polarization is inferred from the first entry (the PDF slot):\n#   POL_PDF / POL_FF  \u2192 polarized coefficient functions are used\n#     DIS:   F2 -&gt; g1,  FL -&gt; gL,  F3 -&gt; g4  (NC only)\n#     SIDIS: F2 -&gt; G1                        (NC only)\n#   UNPOL_PDF / UNPOL_FF \u2192 unpolarized coefficient functions\n# Polarized CC and polarized SIA are not supported.\n# For SIDIS the PDF and FF types can differ independently\n# (e.g. [POL_PDF, UNPOL_FF] for helicity-weighted cross sections).\nConvolutionTypes: [UNPOL_PDF]\n\n# Perturbative orders as 5-element arrays:\n# [alpha_s, alpha, log(xi_R), log(xi_F), log(xi_A)]\n# For QCD-only coefficient functions, set all but alpha_s to 0.\nOrders:\n  - [0, 0, 0, 0, 0]   # O(alpha_s^0) = LO\n  - [1, 0, 0, 0, 0]   # O(alpha_s^1) = NLO\n  - [2, 0, 0, 0, 0]   # O(alpha_s^2) = NNLO\n\n# Partonic channels (optional).\n# Channels are automatically derived by build_grid() from the observable\n# and the number of active flavours. You do not need to specify this field.\n# If present, it will be overridden during grid building.\n#\n# Channels:\n#   - pids: [[2], [-2]]     # u + ubar\n#     factors: [1.0, 1.0]\n#   - pids: [[1], [-1]]     # d + dbar\n#     factors: [1.0, 1.0]\n#   - pids: [[21]]          # gluon\n#     factors: [1.0]\n\n# Kinematic bins. Each bin is defined by lower and upper edges\n# in each dimension:\n#   DIS:   [Q^2, x]        (2 dimensions)\n#   SIA:   [Q^2, z]        (2 dimensions)\n#   SIDIS: [Q^2, x, z]     (3 dimensions)\nBins:\n  - lower: [10.0, 0.001]\n    upper: [100.0, 0.01]\n  - lower: [100.0, 0.01]\n    upper: [1000.0, 0.1]\n\n# Bin normalisation factors (one per bin).\nNormalizations: [1.0, 1.0]\n</code></pre>"},{"location":"grid-creation/#dis-example","title":"DIS example","text":"<p>A DIS \\(F_2\\) grid up to NNLO with two \\((Q^2, x)\\) bins.</p> <pre><code>Process: DIS\nObservable: F2\nCurrent: NC\nPidBasis: PDG\nHadronPids: [2212]\nConvolutionTypes: [UNPOL_PDF]\n\nOrders:\n  - [0, 0, 0, 0, 0]\n  - [1, 0, 0, 0, 0]\n  - [2, 0, 0, 0, 0]\n\nBins:\n  - lower: [10.0, 0.001]\n    upper: [100.0, 0.01]\n  - lower: [100.0, 0.01]\n    upper: [1000.0, 0.1]\n\nNormalizations: [1.0, 1.0]\n</code></pre>"},{"location":"grid-creation/#sia-example","title":"SIA example","text":"<p>An SIA \\(F_2\\) grid for pion production up to NNLO. Note that the second kinematic dimension is the hadron momentum fraction \\(z\\) instead of Bjorken \\(x\\), and the convolution type is <code>UNPOL_FF</code>. Channels are auto-derived as for DIS:</p> <pre><code>Process: SIA\nObservable: F2\nCurrent: NC\nPidBasis: PDG\nHadronPids: [211]\nConvolutionTypes: [UNPOL_FF]\n\nOrders:\n  - [0, 0, 0, 0, 0]\n  - [1, 0, 0, 0, 0]\n  - [2, 0, 0, 0, 0]\n\nBins:\n  - lower: [10.0, 0.2]\n    upper: [100.0, 0.4]\n  - lower: [100.0, 0.4]\n    upper: [1000.0, 0.6]\n\nNormalizations: [1.0, 1.0]\n</code></pre>"},{"location":"grid-creation/#sidis-example","title":"SIDIS example","text":"<p>A SIDIS \\(F_2\\) grid for proton\u2192pion semi-inclusive production up to NLO. Bins are three-dimensional \\((Q^2, x, z)\\) and two convolution types are required (PDF and FF):</p> <pre><code>Process: SIDIS\nObservable: F2\nCurrent: NC\nPidBasis: PDG\nHadronPids: [2212, 211]\nConvolutionTypes: [UNPOL_PDF, UNPOL_FF]\n\nOrders:\n  - [0, 0, 0, 0, 0]   # LO\n  - [1, 0, 0, 0, 0]   # NLO\n\nBins:\n  - lower: [10.0, 0.001, 0.2]\n    upper: [100.0, 0.01, 0.4]\n  - lower: [100.0, 0.01, 0.4]\n    upper: [1000.0, 0.1, 0.6]\n\nNormalizations: [1.0, 1.0]\n</code></pre>"},{"location":"grid-creation/#polarized-dis-example","title":"Polarized DIS example","text":"<p>A polarized DIS \\(g_1\\) grid up to NLO. Setting <code>ConvolutionTypes: [POL_PDF]</code> signals polarized coefficient functions; <code>Observable: F2</code> then selects \\(g_1\\):</p> <pre><code>Process: DIS\nObservable: F2\nCurrent: NC\nPidBasis: PDG\nHadronPids: [2212]\nConvolutionTypes: [POL_PDF]\n\nOrders:\n  - [0, 0, 0, 0, 0]\n  - [1, 0, 0, 0, 0]\n\nBins:\n  - lower: [10.0, 0.001]\n    upper: [100.0, 0.01]\n  - lower: [100.0, 0.01]\n    upper: [1000.0, 0.1]\n\nNormalizations: [1.0, 1.0]\n</code></pre>"},{"location":"grid-creation/#polarized-sidis-example","title":"Polarized SIDIS example","text":"<p>A polarized SIDIS \\(G_1\\) grid up to NLO. Only <code>Observable: F2</code> is valid here. Note that the PDF is polarized while the FF remains unpolarized \u2014 this distinction is expressed directly through <code>ConvolutionTypes</code> without any separate flag:</p> <pre><code>Process: SIDIS\nObservable: F2\nCurrent: NC\nPidBasis: PDG\nHadronPids: [2212, 211]\nConvolutionTypes: [POL_PDF, UNPOL_FF]\n\nOrders:\n  - [0, 0, 0, 0, 0]\n  - [1, 0, 0, 0, 0]\n\nBins:\n  - lower: [10.0, 0.001, 0.2]\n    upper: [100.0, 0.01, 0.4]\n  - lower: [100.0, 0.01, 0.4]\n    upper: [1000.0, 0.1, 0.6]\n\nNormalizations: [1.0, 1.0]\n</code></pre>"},{"location":"grid-creation/#ffn-dis-example","title":"FFN DIS example","text":"<p>A DIS \\(F_2\\) grid in the fixed-flavor-number scheme. Requires <code>HeavyQuarkMasses</code> in the theory card (6 entries). The massive coefficient functions are tabulated internally on a \\(\\xi = Q^2/m^2\\) grid; the tabulation parameters can be tuned with <code>MassNxi</code> etc. in the theory card.</p> <pre><code>Process: DIS\nObservable: F2\nCurrent: NC\nMassScheme: FFN\nPidBasis: PDG\nHadronPids: [2212]\nConvolutionTypes: [UNPOL_PDF]\n\nOrders:\n  - [0, 0, 0, 0, 0]\n  - [1, 0, 0, 0, 0]\n  - [2, 0, 0, 0, 0]\n\nBins:\n  - lower: [10.0, 0.001]\n    upper: [100.0, 0.01]\n  - lower: [100.0, 0.01]\n    upper: [1000.0, 0.1]\n\nNormalizations: [1.0, 1.0]\n</code></pre>"},{"location":"grid-creation/#fonll-dis-example","title":"FONLL DIS example","text":"<p>A DIS \\(F_2\\) FONLL grid. PineAPFEL computes \\(F_\\mathrm{FONLL} = F_\\mathrm{ZM} + F_\\mathrm{FFN}\\) following APFEL++ conventions. The same theory card as for FFN is required.</p> <pre><code>Process: DIS\nObservable: F2\nCurrent: NC\nMassScheme: FONLL\nPidBasis: PDG\nHadronPids: [2212]\nConvolutionTypes: [UNPOL_PDF]\n\nOrders:\n  - [0, 0, 0, 0, 0]\n  - [1, 0, 0, 0, 0]\n  - [2, 0, 0, 0, 0]\n\nBins:\n  - lower: [10.0, 0.001]\n    upper: [100.0, 0.01]\n  - lower: [100.0, 0.01]\n    upper: [1000.0, 0.1]\n\nNormalizations: [1.0, 1.0]\n</code></pre>"},{"location":"grid-creation/#cc-dis-example","title":"CC DIS example","text":"<p>A DIS \\(F_2\\) charged-current (CC) grid with the Plus variant \\((F(\\nu) + F(\\bar\\nu))/2\\). The <code>CCSign</code> field selects between Plus and Minus. The CKM matrix elements are specified in the theory card (see below):</p> <pre><code>Process: DIS\nObservable: F2\nCurrent: CC\nCCSign: Plus\nPidBasis: PDG\nHadronPids: [2212]\nConvolutionTypes: [UNPOL_PDF]\n\nOrders:\n  - [0, 0, 0, 0, 0]\n  - [1, 0, 0, 0, 0]\n  - [2, 0, 0, 0, 0]\n\nBins:\n  - lower: [10.0, 0.001]\n    upper: [100.0, 0.01]\n  - lower: [100.0, 0.01]\n    upper: [1000.0, 0.1]\n\nNormalizations: [1.0, 1.0]\n</code></pre> <p>The theory card should include a <code>CKM</code> field with 9 squared CKM matrix elements \\(|V_{ij}|^2\\) in row-major order: \\([V_{ud}^2, V_{us}^2, V_{ub}^2, V_{cd}^2, V_{cs}^2, V_{cb}^2, V_{td}^2, V_{ts}^2, V_{tb}^2]\\). If absent, standard PDG values are used.</p>"},{"location":"grid-creation/#using-the-cli","title":"Using the CLI","text":"<p>The <code>pineapfel-build</code> executable creates a filled PineAPPL grid from three YAML cards:</p> <pre><code>pineapfel-build &lt;grid.yaml&gt; &lt;theory.yaml&gt; &lt;operator.yaml&gt; [-o output.pineappl.lz4]\n</code></pre> <p>If <code>-o</code> is not specified, the output filename is derived from the grid card by replacing <code>.yaml</code> with <code>.pineappl.lz4</code>.</p> <pre><code># Build a DIS F2 grid\npineapfel-build runcards/grid_dis.yaml runcards/theory.yaml runcards/operator.yaml\n\n# Build an SIA grid with a custom output name\npineapfel-build runcards/grid_sia.yaml runcards/theory.yaml runcards/operator.yaml \\\n    -o sia_f2.pineappl.lz4\n</code></pre>"},{"location":"grid-creation/#using-the-library","title":"Using the library","text":"<p>The same functionality is available programmatically through the <code>build_grid()</code> function:</p> <pre><code>#include &lt;pineapfel.h&gt;\n#include &lt;pineappl_capi.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // 1. Load all three cards\n    auto grid_def = pineapfel::load_grid_def(\"runcards/grid_dis.yaml\");\n    auto theory   = pineapfel::load_theory_card(\"runcards/theory.yaml\");\n    auto op_card  = pineapfel::load_operator_card(\"runcards/operator.yaml\");\n\n    // 2. Build and fill the grid\n    auto* grid = pineapfel::build_grid(grid_def, theory, op_card);\n\n    // 3. Write the grid\n    pineappl_grid_write(grid, \"dis_f2.pineappl.lz4\");\n\n    // 4. Cleanup\n    pineappl_grid_delete(grid);\n    return 0;\n}\n</code></pre> <p>The returned grid can also be passed directly to <code>pineapfel::evolve()</code> to produce an FK table in the same program:</p> <pre><code>auto* grid    = pineapfel::build_grid(grid_def, theory, op_card);\nauto* fktable = pineapfel::evolve(grid, theory, op_card);\npineappl_grid_write(fktable, \"dis_f2.fk.pineappl.lz4\");\npineappl_grid_delete(fktable);\npineappl_grid_delete(grid);\n</code></pre>"},{"location":"grid-creation/#grid-structure-internals","title":"Grid structure internals","text":"<p>Understanding the internal layout of the generated grid is useful for debugging and for writing custom grid-filling code.</p>"},{"location":"grid-creation/#node-selection","title":"Node selection","text":"<p>The grid nodes are defined automatically:</p> <ul> <li> <p>\\(x/z\\) nodes: Taken from the APFEL++ joint interpolation grid, which is built from   the <code>xgrid</code> definition in the operator card. This ensures consistency between the   coefficient function grid and any subsequent evolution step.</p> </li> <li> <p>\\(Q^2\\) nodes: Derived from the bin edges in the grid card. The bin boundaries in the   first dimension (\\(Q^2\\)) are collected, and geometrically spaced intermediate points are   added within each bin. Additionally, quark threshold values (\\(m_q^2\\)) that fall within   the overall \\(Q^2\\) range are included to capture flavour-threshold effects.</p> </li> </ul>"},{"location":"grid-creation/#subgrid-layout","title":"Subgrid layout","text":""},{"location":"grid-creation/#dis-and-sia","title":"DIS and SIA","text":"<p>Each subgrid (one per combination of bin, perturbative order, and channel) is a two-dimensional array of shape <code>[n_Q2, n_x]</code>, stored in row-major order. The <code>node_values</code> vector concatenates the \\(Q^2\\) nodes followed by the \\(x\\)/\\(z\\) nodes:</p> <pre><code>node_values = [Q^2_0, ..., Q^2_{nq-1}, x_0, ..., x_{nx-1}]\n</code></pre> <p>For each \\(Q^2\\) node, the coefficient function operator is evaluated at the bin's \\(x\\)/\\(z\\) centre (geometric mean of the bin edges) to produce a distribution on the APFEL++ joint grid, which populates one row of the subgrid.</p>"},{"location":"grid-creation/#sidis","title":"SIDIS","text":"<p>SIDIS subgrids are three-dimensional arrays of shape <code>[n_Q2, n_x, n_z]</code>, stored in row-major order. The same APFEL++ joint grid is used for both the \\(x\\) (PDF) and \\(z\\) (FF) dimensions. The <code>node_values</code> vector concatenates three segments:</p> <pre><code>node_values = [Q^2_0, ..., Q^2_{nq-1}, x_0, ..., x_{nx-1}, z_0, ..., z_{nz-1}]\n</code></pre> <p>For each \\(Q^2\\) node and each <code>DoubleObject</code> term in the coefficient function, the \\(x\\)-distribution is evaluated at the bin's \\(x\\)-centre and the \\(z\\)-distribution at the bin's \\(z\\)-centre (both geometric means). The subgrid entry at <code>[iq, ix, iz]</code> is the outer product of these two distributions, weighted by \\(e_q^2\\) and the term coefficient:</p> <pre><code>subgrid[iq, ix, iz] = e_q^2 * sum_terms { c_term * K_x(x[ix]; x_centre) * K_z(z[iz]; z_centre) }\n</code></pre> <p>where \\(K_x\\) and \\(K_z\\) are the APFEL++ distribution kernels in the \\(x\\) and \\(z\\) directions respectively.</p>"},{"location":"grid-creation/#programmatic-grid-definition","title":"Programmatic grid definition","text":"<p>In addition to loading from YAML, you can construct a <code>GridDef</code> programmatically. Note that <code>channels</code> can be left empty \u2014 <code>build_grid()</code> will auto-derive them:</p> <pre><code>pineapfel::GridDef def;\ndef.process    = pineapfel::ProcessType::DIS;\ndef.observable = pineapfel::Observable::F2;\ndef.current    = pineapfel::Current::NC;\ndef.pid_basis  = PINEAPPL_PID_BASIS_PDG;\ndef.hadron_pids        = {2212};\ndef.convolution_types  = {PINEAPPL_CONV_TYPE_UNPOL_PDF};\n\ndef.orders = {{0, 0, 0, 0, 0}, {1, 0, 0, 0, 0}, {2, 0, 0, 0, 0}};  // LO + NLO + NNLO\n// channels are auto-derived by build_grid() \u2014 no need to set them\ndef.bins = {\n    {{10.0, 0.001}, {100.0, 0.01}},\n    {{100.0, 0.01}, {1000.0, 0.1}},\n};\ndef.normalizations = {1.0, 1.0};\n\nauto* grid = pineapfel::build_grid(def, theory, op_card);\n</code></pre> <p>You can also call <code>derive_channels()</code> directly if you need the channels before calling <code>build_grid()</code>:</p> <pre><code>// Derive channels for DIS F2 NC with 5 active flavours\nauto channels = pineapfel::derive_channels(\n    pineapfel::ProcessType::DIS,\n    pineapfel::Observable::F2,\n    pineapfel::Current::NC,\n    pineapfel::CCSign::Plus,\n    5);\n// Returns 6 channels: d+dbar, u+ubar, s+sbar, c+cbar, b+bbar, gluon\n\n// Derive channels for SIDIS F2 with 5 active flavours\nauto sidis_channels = pineapfel::derive_channels(\n    pineapfel::ProcessType::SIDIS,\n    pineapfel::Observable::F2,\n    pineapfel::Current::NC,\n    pineapfel::CCSign::Plus,\n    5);\n// Returns 15 channels: (qq, gq, qg) x 5 quarks\n</code></pre>"},{"location":"library/","title":"Using as a Library","text":""},{"location":"library/#using-the-library","title":"Using the library","text":"<p>Include the single convenience header to access the full API:</p> <pre><code>#include &lt;pineapfel.h&gt;\n</code></pre>"},{"location":"library/#api-overview","title":"API overview","text":"<p>PineAPFEL exposes three main modules:</p> Module Header Functions Cards <code>cards.h</code> <code>load_theory_card()</code>, <code>load_operator_card()</code> Grid creation <code>grid_gen.h</code>, <code>fill.h</code> <code>load_grid_def()</code>, <code>derive_channels()</code>, <code>create_grid()</code>, <code>build_grid()</code> Evolution <code>evolution.h</code> <code>evolve()</code> SIDIS coefficients <code>sidis_api.h</code> <code>init_sidis()</code>, <code>SidisCoeffs</code> <p><code>sidis_api.h</code> is an internal header used by <code>build_grid()</code> to load the SIDIS coefficient functions from APFEL++ without exposing <code>&lt;apfel/SIDIS.h&gt;</code> to other translation units. You do not need to include it in application code.</p>"},{"location":"library/#grid-creation-example","title":"Grid creation example","text":"<p>Build a PineAPPL grid filled with APFEL++ coefficient functions:</p> <pre><code>#include &lt;pineapfel.h&gt;\n#include &lt;pineappl_capi.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // 1. Load the three YAML cards\n    auto grid_def = pineapfel::load_grid_def(\"grid_dis.yaml\");\n    auto theory   = pineapfel::load_theory_card(\"theory.yaml\");\n    auto op_card  = pineapfel::load_operator_card(\"operator.yaml\");\n\n    // 2. Build and fill the grid with coefficient functions\n    auto* grid = pineapfel::build_grid(grid_def, theory, op_card);\n\n    // 3. Write the grid\n    pineappl_grid_write(grid, \"dis_f2.pineappl.lz4\");\n    pineappl_grid_delete(grid);\n\n    return 0;\n}\n</code></pre> <p>The same <code>build_grid()</code> call works unchanged for SIDIS, polarized grids, and massive schemes \u2014 the relevant flags are read from the grid card:</p> <pre><code>// SIDIS (two-convolution: PDF \u2297 FF)\nauto grid_def = pineapfel::load_grid_def(\"grid_sidis.yaml\");  // Process: SIDIS\nauto* grid    = pineapfel::build_grid(grid_def, theory, op_card);\npineappl_grid_write(grid, \"sidis_f2.pineappl.lz4\");\npineappl_grid_delete(grid);\n\n// Polarized DIS g1 (Polarized: true in card)\nauto pol_def = pineapfel::load_grid_def(\"grid_dis_pol.yaml\");\nauto* pol_grid = pineapfel::build_grid(pol_def, theory, op_card);\npineappl_grid_write(pol_grid, \"dis_g1.pineappl.lz4\");\npineappl_grid_delete(pol_grid);\n\n// FFN DIS F2 (MassScheme: FFN in card, HeavyQuarkMasses in theory card)\nauto ffn_def = pineapfel::load_grid_def(\"grid_dis_ffn.yaml\");\nauto* ffn_grid = pineapfel::build_grid(ffn_def, theory, op_card);\npineappl_grid_write(ffn_grid, \"dis_f2_ffn.pineappl.lz4\");\npineappl_grid_delete(ffn_grid);\n\n// FONLL DIS F2 (MassScheme: FONLL in card)\nauto fonll_def = pineapfel::load_grid_def(\"grid_dis_fonll.yaml\");\nauto* fonll_grid = pineapfel::build_grid(fonll_def, theory, op_card);\npineappl_grid_write(fonll_grid, \"dis_f2_fonll.pineappl.lz4\");\npineappl_grid_delete(fonll_grid);\n</code></pre> <p>When building programmatically, polarization is inferred from <code>convolution_types</code>: setting the first entry to <code>PINEAPPL_CONV_TYPE_POL_PDF</code> selects polarized coefficient functions. Use <code>grid_def.mass_scheme</code> to select a heavy-quark scheme:</p> <pre><code>// Polarized DIS g1: POL_PDF in convolution_types drives the coefficient function choice\npineapfel::GridDef def;\ndef.process    = pineapfel::ProcessType::DIS;\ndef.observable = pineapfel::Observable::F2;  // interpreted as g1\ndef.current    = pineapfel::Current::NC;\ndef.pid_basis  = PINEAPPL_PID_BASIS_PDG;\ndef.hadron_pids       = {2212};\ndef.convolution_types = {PINEAPPL_CONV_TYPE_POL_PDF};\ndef.orders = {{0, 0, 0, 0, 0}, {1, 0, 0, 0, 0}};\ndef.bins = {{{10.0, 0.001}, {100.0, 0.01}}};\ndef.normalizations = {1.0};\n\nauto* pol_grid = pineapfel::build_grid(def, theory, op_card);\n\n// FFN DIS F2 (theory card must contain HeavyQuarkMasses with 6 entries)\npineapfel::GridDef ffn_def;\nffn_def.process      = pineapfel::ProcessType::DIS;\nffn_def.observable   = pineapfel::Observable::F2;\nffn_def.current      = pineapfel::Current::NC;\nffn_def.mass_scheme  = pineapfel::MassScheme::FFN;   // &lt;-- key field\nffn_def.pid_basis    = PINEAPPL_PID_BASIS_PDG;\nffn_def.hadron_pids       = {2212};\nffn_def.convolution_types = {PINEAPPL_CONV_TYPE_UNPOL_PDF};\nffn_def.orders = {{0, 0, 0, 0, 0}, {1, 0, 0, 0, 0}, {2, 0, 0, 0, 0}};\nffn_def.bins = {{{10.0, 0.001}, {100.0, 0.01}}};\nffn_def.normalizations = {1.0};\n\nauto* ffn_grid = pineapfel::build_grid(ffn_def, theory, op_card);\n</code></pre> <p>See Grid creation for details on the grid card format and supported processes.</p>"},{"location":"library/#evolution-example","title":"Evolution example","text":"<p>Evolve an existing PineAPPL grid into an FK table:</p> <pre><code>#include &lt;pineapfel.h&gt;\n#include &lt;pineappl_capi.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // 1. Load configuration cards from YAML\n    auto theory  = pineapfel::load_theory_card(\"theory.yaml\");\n    auto op_card = pineapfel::load_operator_card(\"operator.yaml\");\n\n    // 2. Read the PineAPPL grid\n    auto* grid = pineappl_grid_read(\"grid.pineappl.lz4\");\n\n    // 3. Evolve into an FK table\n    auto* fktable = pineapfel::evolve(grid, theory, op_card);\n\n    // 4. Write out the FK table\n    pineappl_grid_write(fktable, \"fktable.pineappl.lz4\");\n\n    // 5. Cleanup\n    pineappl_grid_delete(fktable);\n    pineappl_grid_delete(grid);\n\n    return 0;\n}\n</code></pre>"},{"location":"library/#full-pipeline-example","title":"Full pipeline example","text":"<p>Create a grid and evolve it in one program:</p> <pre><code>#include &lt;pineapfel.h&gt;\n#include &lt;pineappl_capi.h&gt;\n\nint main() {\n    auto grid_def = pineapfel::load_grid_def(\"grid_dis.yaml\");\n    auto theory   = pineapfel::load_theory_card(\"theory.yaml\");\n    auto op_card  = pineapfel::load_operator_card(\"operator.yaml\");\n\n    // Build the coefficient function grid\n    auto* grid = pineapfel::build_grid(grid_def, theory, op_card);\n\n    // Evolve into an FK table\n    auto* fktable = pineapfel::evolve(grid, theory, op_card);\n\n    // Write out\n    pineappl_grid_write(fktable, \"dis_f2.fk.pineappl.lz4\");\n\n    pineappl_grid_delete(fktable);\n    pineappl_grid_delete(grid);\n\n    return 0;\n}\n</code></pre>"},{"location":"library/#building-your-own-program-against-pineapfel","title":"Building your own program against <code>pineapfel</code>","text":"<p>If <code>pineapfel</code> is installed, you can link against it in your <code>CMakeLists.txt</code>:</p> <pre><code>find_library(PINEAPFEL_LIB pineapfel)\ntarget_link_libraries(my_program PRIVATE ${PINEAPFEL_LIB})\ntarget_include_directories(my_program PRIVATE /path/to/pineapfel/include)\n</code></pre> <p>Or compile directly with the source tree:</p> <pre><code>add_subdirectory(pineapfel)\ntarget_link_libraries(my_program PRIVATE pineapfel)\n</code></pre>"},{"location":"python-api/","title":"Python API","text":""},{"location":"python-api/#python-api","title":"Python API","text":"<p><code>PineAPFEL</code> ships a Python package \u2014 <code>pineapfel</code> \u2014 built with pybind11 and compiled as part of the normal Meson build. It exposes the same card-loading, grid-building, and evolution functions as the C++ library, and returns grids that can be directly handed to PineAPPL for convolution and analysis.</p> <p>See Building for installation instructions.</p>"},{"location":"python-api/#grid-creation","title":"Grid creation","text":"<p>Build a <code>PineAPPL</code> grid filled with <code>APFEL++</code> coefficient functions:</p> <pre><code>import pineapfel\n\n# 1. Load the three YAML cards\ntheory  = pineapfel.load_theory_card(\"runcards/theory.yaml\")\nop_card = pineapfel.load_operator_card(\"runcards/operator.yaml\")\ngdef    = pineapfel.load_grid_def(\"runcards/grid_dis.yaml\")\n\n# 2. Build and fill the grid with coefficient functions\ngrid = pineapfel.build_grid(gdef, theory, op_card)\n\n# 3. Write to disk\ngrid.write(\"dis_f2.pineappl.lz4\")\n</code></pre> <p>The same <code>build_grid()</code> call works for all supported processes; the relevant flags are read from the grid card:</p> <pre><code># SIDIS (PDF \u2297 FF, two convolution functions)\nsidis_def = pineapfel.load_grid_def(\"runcards/grid_sidis.yaml\")\nsidis_grid = pineapfel.build_grid(sidis_def, theory, op_card)\nsidis_grid.write(\"sidis_f2.pineappl.lz4\")\n\n# Polarized DIS g\u2081\npol_def  = pineapfel.load_grid_def(\"runcards/grid_dis_pol.yaml\")\npol_grid = pineapfel.build_grid(pol_def, theory, op_card)\npol_grid.write(\"dis_g1.pineappl.lz4\")\n\n# Fixed-Flavour Number (FFN) massive scheme\nffn_def  = pineapfel.load_grid_def(\"runcards/grid_dis_ffn.yaml\")\nffn_grid = pineapfel.build_grid(ffn_def, theory, op_card)\nffn_grid.write(\"dis_f2_ffn.pineappl.lz4\")\n\n# FONLL combined scheme\nfonll_def  = pineapfel.load_grid_def(\"runcards/grid_dis_fonll.yaml\")\nfonll_grid = pineapfel.build_grid(fonll_def, theory, op_card)\nfonll_grid.write(\"dis_f2_fonll.pineappl.lz4\")\n</code></pre>"},{"location":"python-api/#evolution","title":"Evolution","text":"<p>Evolve an existing grid into an FK table:</p> <pre><code>import pineapfel\n\ntheory  = pineapfel.load_theory_card(\"runcards/theory.yaml\")\nop_card = pineapfel.load_operator_card(\"runcards/operator.yaml\")\n\n# Read an existing PineAPPL grid\ngrid = pineapfel.Grid.read(\"dis_f2.pineappl.lz4\")\n\n# Evolve into an FK table\nfktable = pineapfel.evolve(grid, theory, op_card)\nfktable.write(\"dis_f2.fk.pineappl.lz4\")\n</code></pre>"},{"location":"python-api/#convolution-using-pineappl-api","title":"Convolution using PineAPPL API","text":"<p>The <code>Grid</code> object returned by <code>build_grid</code> and <code>evolve</code> can be written to disk and read back by PineAPPL for convolution with PDFs:</p> <pre><code>import lhapdf\nimport numpy as np\nimport pineapfel\n\nfrom pineappl.grid import Grid\nfrom pineappl.convolutions import Conv, ConvType\n\n# \u2500\u2500 Build the grid\ntheory  = pineapfel.load_theory_card(\"runcards/theory.yaml\")\nop_card = pineapfel.load_operator_card(\"runcards/operator.yaml\")\ngdef    = pineapfel.load_grid_def(\"runcards/grid_dis.yaml\")\ngrid    = pineapfel.build_grid(gdef, theory, op_card)\ngrid.write(\"dis_f2.pineappl.lz4\")\n\n# \u2500\u2500 Read back with PineAPPL\npg = Grid.read(\"dis_f2.pineappl.lz4\")\n\n# \u2500\u2500 Set up the PDF set\npdf = lhapdf.mkPDF(\"NNPDF40_nnlo_as_01180\", 0)\n\ndef xfx(pid, x, q2):\n    return pdf.xfxQ2(pid, x, q2)\n\ndef alphas(q2):\n    return pdf.alphasQ2(q2)\n\n# \u2500\u2500 Convolve\nct  = ConvType(polarized=False, time_like=False)\nc   = Conv(ct, 2212)                             # proton (PDG id 2212)\nres = pg.convolve(pdg_convs=[c], xfxs=[xfx], alphas=alphas)\nprint(\"F2 per bin:\", res)\n</code></pre>"},{"location":"python-api/#programmatic-grid-definition","title":"Programmatic grid definition","text":"<p>Cards can also be constructed in Python without YAML files:</p> <pre><code>import pineapfel\n\ntheory = pineapfel.TheoryCard()\ntheory.mu0           = 1.0\ntheory.pert_ord      = 2\ntheory.q_ref         = 91.2\ntheory.alpha_qcd_ref = 0.118\ntheory.quark_thresholds = [0.3, 1.5, 4.5, 100.0, 100.0]\ntheory.flavors          = [1, 2, 3, 4, 5, 6]\ntheory.ckm              = [1.0, 0.0, 0.0] * 3   # diagonal CKM\ntheory.qed              = False\ntheory.alpha_qed_ref    = 1.0 / 137.0\ntheory.lepton_thresholds = []\ntheory.heavy_quark_masses = [0.3, 1.5, 4.5, 100.0, 100.0, 100.0]\n\nop_card = pineapfel.OperatorCard()\nop_card.xgrid      = [pineapfel.SubGridDef(100, 1e-7, 3)]\nop_card.tabulation = pineapfel.TabulationParams(50, 1.0, 200, 3)\nop_card.xi         = [1.0, 1.0, 1.0]\n\ngdef = pineapfel.GridDef()\ngdef.process           = pineapfel.ProcessType.DIS\ngdef.observable        = pineapfel.Observable.F2\ngdef.current           = pineapfel.Current.NC\ngdef.mass_scheme       = pineapfel.MassScheme.ZM\ngdef.pid_basis         = pineapfel.PidBasis.PDG\ngdef.hadron_pids       = [2212]\ngdef.convolution_types = [pineapfel.ConvolutionType.UNPOL_PDF]\ngdef.orders            = [pineapfel.OrderDef(0, 0, 0, 0, 0),\n                          pineapfel.OrderDef(1, 0, 0, 0, 0)]\ngdef.bins = [\n    pineapfel.BinDef([10.0,  0.001], [100.0,  0.01]),\n    pineapfel.BinDef([100.0, 0.01 ], [1000.0, 0.1 ]),\n]\ngdef.normalizations = [1.0, 1.0]\n\ngrid = pineapfel.build_grid(gdef, theory, op_card)\ngrid.write(\"my_dis_f2.pineappl.lz4\")\n</code></pre>"}]}